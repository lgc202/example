package day02

//整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。
//
//
// 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
//
//
// 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就
//是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
//
//
// 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
// 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
// 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
//
//
// 给你一个整数数组 nums ，找出 nums 的下一个排列。
//
// 必须 原地 修改，只允许使用额外常数空间。
//
//
//
// 示例 1：
//
//
//输入：nums = [1,2,3]
//输出：[1,3,2]
//
//
// 示例 2：
//
//
//输入：nums = [3,2,1]
//输出：[1,2,3]
//
//
// 示例 3：
//
//
//输入：nums = [1,1,5]
//输出：[1,5,1]
//
//
//
//
// 提示：
//
//
// 1 <= nums.length <= 100
// 0 <= nums[i] <= 100
//
//
// Related Topics 数组 双指针 👍 2278 👎 0

// 思路: 要想使得数字变大，只要任意一位变大就可以, 这里变大数字，只能利用交换。
//
// (1) 如果从个位开始，从右往左进行，找一个比个位大的，交换过来，个位的数字交换到了更高位，由于个位的数字较小，
//     所以交换过去虽然个位变大了，但数字整体变小了。 例如 1 3 2，把 2 和 3 交换，变成 1 2 3，个位变大了，但整体数字变小了。
//
// (2) 个位不行，我们再看十位，如果从十位左边找一个更大的数字交换过来，和个位的情况是一样的，数字会变小。
//     例如 4 1 2 3，把 2 和 4 交换，2 1 4 3，数字会变小。如果从右边找一个更大的数字交换过来，由于是从低位交换过来的，
//     所以数字满足了会变大。如 4 1 2 3，把 2 和 3 交换，变成 4 1 3 2 数字变大了。
//
// (3) 如果十位右边没有比十位数字大的，我们就左移看下一位，再看当前位右边，有没有更大的数字，没有就一直左移就可以。
//
// (4) 还有一个问题，如果右边有不止一个大于当前位的数字选哪个？选那个刚好大于当前位的，这样会保证数字整体尽可能的小。
//
// (5) 交换完结束了吗？并没有。因为交换完数字变大了，但并不一定是刚好大于原数字的。例如 158476531，我们从十位开始，
//     十位右边没有大于 3 的。再看百位，百位右边没有大于 5 的。直到 4 ，右边出现了很多大于 4 的，选那个刚好大于 4 的，也就是 5。
//     然后交换，变成 158576431，数字变大了，但并不是刚好大于 158476531，我们还需要将 5 右边的数字从小到大排列。变成158513467，就可以结束了。
//
// (6) 而最后的排序，我们其实并不需要用排序函数，因为交换的位置也就是 5 的右边的数字一定是降序的，我们只需要倒序即可了。

func nextPermutation(nums []int) {
	if len(nums) < 2 {
		return
	}

	// 从十位开始
	i := len(nums) - 2

	// 从右往左找到第一个不是递增的位置
	for i > 0 {
		if nums[i] >= nums[i+1] {
			i--
			continue
		}
		break
	}

	// 如果找不到, 直接返回升序数组
	// 如 321 的下一个是 123
	if i == 0 && nums[i] > nums[i+1] {
		reverse31(nums, 0, len(nums)-1)
		return
	}

	// 找到 i 的右边第一个比它大的数字, 交换两者的位置
	j := len(nums) - 1
	for j > i {
		if nums[j] <= nums[i] {
			j--
			continue
		}
		break
	}

	nums[i], nums[j] = nums[j], nums[i]

	// 把 i 右边的元素进行递增排序
	// 由第一步可以知道, i 右边的元素现在是从左往右递减
	reverse31(nums, i+1, len(nums)-1)
}

func reverse31(nums []int, start, end int) {
	for start < end {
		nums[start], nums[end] = nums[end], nums[start]
		start++
		end--
	}
}
